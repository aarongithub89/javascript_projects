<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Sphere Rolling Down Mountain</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      color: white;
      background-color: #1a1a1a;
    }
    canvas {
      display: block;
    }
    #titleContainer {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      z-index: 10;
    }
    #titleContainer h1 {
      margin: 0;
      font-size: 24px;
    }
    #titleContainer p {
      margin: 5px 0 0;
      font-size: 16px;
    }
  </style>
  <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.148.0/build/three.module.js"
        }
    }
  </script>
</head>
<body>
<div id="titleContainer">
  <h1>3D Sphere Rolling Down Mountain</h1>
  <p>Use arrow keys to control the camera!</p>
</div>

<script type="module">
  import * as THREE from 'three';

  console.log('Module script started');

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000);
  document.body.appendChild(renderer.domElement);

  scene.background = new THREE.Color().setStyle('#87ceeb');

  const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 10, 7.5);
  scene.add(directionalLight);

  const terrainGeometry = new THREE.PlaneGeometry(100, 150, 100, 150);
  for (let i = 0; i < terrainGeometry.attributes.position.array.length; i += 3) {
    const x = terrainGeometry.attributes.position.array[i];
    const y = terrainGeometry.attributes.position.array[i + 1];
    const z = terrainGeometry.attributes.position.array[i + 2];
    const height = Math.sin(x * 0.1) * Math.cos(y * 0.1) * 2 + (Math.random() - 0.5) * 0.5 - y * 0.2;
    terrainGeometry.attributes.position.array[i + 2] = y > 75 ? height - (y - 75) * 0.1 : height;
  }
  terrainGeometry.computeVertexNormals();
  const terrainMaterial = new THREE.MeshPhongMaterial({ color: 0x4a3728, flatShading: true });
  const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
  terrain.rotation.x = -Math.PI / 2;
  terrain.position.y = -5;
  scene.add(terrain);
  console.log('Terrain created at', terrain.position);

  const sphereRadius = 1;
  const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
  const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
  const vertexColors = [];
  const faces = sphereGeometry.getIndex().array;
  for (let i = 0; i < faces.length; i += 3) {
    const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
    for (let j = 0; j < 3; j++) {
      vertexColors[faces[i + j]] = color;
    }
  }
  sphereGeometry.setAttribute('color', new THREE.Float32BufferAttribute(vertexColors.flatMap(c => [c.r, c.g, c.b]), 3));
  const sphereMaterial = new THREE.MeshPhongMaterial({
    vertexColors: true,
    transparent: true,
    opacity: 0.5
  });
  const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  sphere.position.set(0, 10, 10);
  scene.add(sphere);
  console.log('Sphere created at', sphere.position);

  const smallBalls = [];
  const smallBallRadius = 0.2;
  const smallBallGeometry = new THREE.SphereGeometry(smallBallRadius, 16, 16);
  for (let i = 0; i < 5; i++) {
    const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
    const smallBall = new THREE.Mesh(smallBallGeometry, material);
    smallBall.position.set(
      (Math.random() - 0.5) * (sphereRadius - 2 * smallBallRadius),
      (Math.random() - 0.5) * (sphereRadius - 2 * smallBallRadius),
      (Math.random() - 0.5) * (sphereRadius - 2 * smallBallRadius)
    );
    sphere.add(smallBall);
    smallBall.velocity = new THREE.Vector3(0, 0, 0);
    smallBalls.push(smallBall);
  }
  console.log('Small balls created');

  const trails = [];
  function addTrailParticle(ball) {
    const trailGeometry = new THREE.SphereGeometry(0.05, 8, 8);
    const trailMaterial = new THREE.MeshBasicMaterial({
      color: ball.material.color,
      transparent: true,
      opacity: 0.5
    });
    const trailParticle = new THREE.Mesh(trailGeometry, trailMaterial);
    const worldPos = ball.position.clone();
    sphere.localToWorld(worldPos);
    trailParticle.position.copy(worldPos);
    scene.add(trailParticle);
    trails.push(trailParticle);

    setTimeout(() => {
      scene.remove(trailParticle);
      const index = trails.indexOf(trailParticle);
      if (index !== -1) trails.splice(index, 1);
    }, 1000);
  }

  const ripples = [];
  function addRipple(x, y, z, normal) {
    const geometry = new THREE.CircleGeometry(0.3, 16);
    const material = new THREE.MeshBasicMaterial({ color: 0x87ceeb, transparent: true, opacity: 0.5 });
    const worldPos = new THREE.Vector3(x, y, z);
    sphere.localToWorld(worldPos);
    const ripple = new THREE.Mesh(geometry, material);
    ripple.position.copy(worldPos);
    if (normal.x !== 0) ripple.rotation.y = Math.PI / 2;
    if (normal.z !== 0) ripple.rotation.x = Math.PI / 2;
    scene.add(ripple);
    ripples.push(ripple);

    let scale = 0.3;
    const rippleInterval = setInterval(() => {
      scale += 0.05;
      ripple.scale.set(scale, scale, 1);
      ripple.material.opacity -= 0.05;
      if (ripple.material.opacity <= 0) {
        scene.remove(ripple);
        const index = ripples.indexOf(ripple);
        if (index !== -1) ripples.splice(index, 1);
        clearInterval(rippleInterval);
      }
    }, 50);
  }

  const dt = 1 / 60;
  const gravity = new THREE.Vector3(0, -9.81, 0);
  const restitution = 0.8;
  let sphereVelocity = new THREE.Vector3(0, 0, 0);
  let sphereAngularVelocity = new THREE.Vector3(0, 0, 0);

  function updatePhysics() {
    sphereVelocity.add(gravity.clone().multiplyScalar(dt));
    sphere.position.add(sphereVelocity.clone().multiplyScalar(dt));
    sphere.rotation.x += sphereAngularVelocity.x;
    sphere.rotation.y += sphereAngularVelocity.y;
    sphere.rotation.z += sphereAngularVelocity.z;

    const ray = new THREE.Raycaster(sphere.position, new THREE.Vector3(0, -1, 0), 0, sphereRadius + 0.1);
    const intersects = ray.intersectObject(terrain, true);
    if (intersects.length > 0) {
      const intersection = intersects[0];
      const normal = intersection.face.normal.clone();
      terrain.localToWorld(normal);
      normal.sub(terrain.position).normalize();

      const overlap = (sphereRadius + 0.1) - intersection.distance;
      if (overlap > 0) {
        sphere.position.add(normal.clone().multiplyScalar(overlap));
        const dot = sphereVelocity.dot(normal);
        if (dot < 0) {
          sphereVelocity.sub(normal.clone().multiplyScalar(2 * dot * restitution));
          const relativePos = intersection.point.clone().sub(sphere.position);
          const velocityChange = sphereVelocity.clone().sub(sphereVelocity.clone().projectOnVector(normal));
          const angularImpulse = relativePos.clone().cross(velocityChange);
          sphereAngularVelocity.add(angularImpulse.multiplyScalar(0.1 / sphereRadius));
        }
      }
    }

    smallBalls.forEach(ball => {
      const worldPos = ball.position.clone();
      sphere.localToWorld(worldPos);
      const worldVel = ball.velocity.clone();
      sphere.localToWorld(worldVel);
      worldVel.sub(sphere.position);

      ball.velocity.add(gravity.clone().multiplyScalar(dt));
      const nextLocalPos = ball.position.clone().add(ball.velocity.clone().multiplyScalar(dt));

      const distanceFromCenter = nextLocalPos.length();
      const maxDistance = sphereRadius - smallBallRadius;

      let collided = false;
      if (distanceFromCenter >= maxDistance) {
        const normal = nextLocalPos.clone().normalize();
        ball.position.copy(normal.clone().multiplyScalar(maxDistance));
        const dot = ball.velocity.dot(normal);
        if (dot < 0) {
          ball.velocity.sub(normal.clone().multiplyScalar(2 * dot * restitution));
          addRipple(ball.position.x, ball.position.y, ball.position.z, normal);
          collided = true;
        }
      } else {
        ball.position.copy(nextLocalPos);
      }

      if (collided && Math.random() < 0.1) {
        addTrailParticle(ball);
      }
    });
  }

  let isDragging = false;
  let previousMousePosition = { x: 0, y: 0 };
  let cageAngularVelocity = new THREE.Vector3(0, 0, 0);

  window.addEventListener('mousedown', (event) => {
    if (event.button === 0) {
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }
  });

  window.addEventListener('mousemove', (event) => {
    if (isDragging) {
      const deltaX = event.clientX - previousMousePosition.x;
      const deltaY = event.clientY - previousMousePosition.y;
      cageAngularVelocity.x = deltaY * 0.005;
      cageAngularVelocity.y = deltaX * 0.005;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    }
  });

  window.addEventListener('mouseup', () => {
    isDragging = false;
  });

  let cameraAngle = 0;
  let orbitRadius = 15;
  let manualControl = false;
  let angleSpeed = 0;
  let zoomSpeed = 0;

  function updateCamera() {
    if (!manualControl) {
      cameraAngle += 0.01;
    } else {
      cameraAngle += angleSpeed;
      orbitRadius = Math.max(5, Math.min(30, orbitRadius + zoomSpeed));
    }
    const height = sphereRadius + 5;
    camera.position.x = orbitRadius * Math.cos(cameraAngle) + sphere.position.x;
    camera.position.z = orbitRadius * Math.sin(cameraAngle) + sphere.position.z;
    camera.position.y = height + sphere.position.y;
    camera.lookAt(sphere.position);
  }

  window.addEventListener('keydown', (event) => {
    manualControl = true;
    switch (event.key) {
      case 'ArrowLeft':
        angleSpeed = -0.02;
        break;
      case 'ArrowRight':
        angleSpeed = 0.02;
        break;
      case 'ArrowUp':
        zoomSpeed = -0.1;
        break;
      case 'ArrowDown':
        zoomSpeed = 0.1;
        break;
    }
  });

  window.addEventListener('keyup', (event) => {
    switch (event.key) {
      case 'ArrowLeft':
      case 'ArrowRight':
        angleSpeed = 0;
        break;
      case 'ArrowUp':
      case 'ArrowDown':
        zoomSpeed = 0;
        break;
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    updatePhysics();
    updateCamera();
    renderer.render(scene, camera);
    console.log('Rendering frame');
  }

  console.log('Starting animation');
  requestAnimationFrame(animate);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
